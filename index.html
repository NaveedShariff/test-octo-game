<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spider Swinger</title>
  <style>
    :root{
      --sky1:#0b1f3a;
      --sky2:#0e355f;
      --sky3:#155a9c;
      --ground:#0b0f1a;
      --building:#101826;
      --building2:#0e1a2b;
      --accent:#ff2d55;
      --ui:#ffffff;
      --shadow:rgba(0,0,0,.3);
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--sky1),var(--sky2) 40%,var(--sky3) 90%);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;color:var(--ui);}    
    #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
    canvas{width:100vw;height:100vh;display:block}
    .hud{position:fixed;left:0;top:0;right:0;display:flex;justify-content:space-between;align-items:flex-start;padding:12px 16px;pointer-events:none}
    .score{font-weight:700;font-size:20px;text-shadow:0 2px 6px var(--shadow)}
    .hint{opacity:.8;font-size:12px}
    .badge{background:rgba(255,255,255,.08);backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,.15);padding:8px 10px;border-radius:12px;box-shadow:0 8px 20px -8px var(--shadow)}

    /* Overlays */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:5}
    .overlay.show{display:flex}
    .panel{width:min(92vw,820px);background:rgba(16,24,38,.9);border:1px solid rgba(255,255,255,.18);border-radius:16px;box-shadow:0 24px 60px -24px rgba(0,0,0,.6);padding:20px}
    .panel h2{margin:6px 0 14px 0;font-size:24px}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .col{flex:1 1 280px}
    .controls-bar{display:flex;gap:10px;flex-wrap:wrap;margin-top:16px}
    .btn-ui{pointer-events:auto;padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.08);color:var(--ui);font-weight:700;cursor:pointer;display:flex;align-items:center;justify-content:center}
    .btn-ui:active{transform:translateY(1px)}
    .input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.2);color:var(--ui)}
    .label{font-size:13px;opacity:.85;margin-bottom:6px;display:block}

    /* Top-right Menu button */
    #openMenuBtn{position:fixed;right:16px;top:60px;z-index:6}

    /* Mobile controls */
    .controls{position:fixed;inset:0;pointer-events:none}
    .pad{position:absolute;bottom:22px;display:flex;gap:14px;pointer-events:auto}
    .pad.left{
      left:22px;
      flex-direction:column;   /* stack vertically */
      gap:16px;                /* space between left & right buttons */
    }
    .pad.right{right:22px}


    /* Default buttons (Left & Right) */
    .btn{
      width:90px;
      height:90px;
      border-radius:22px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      font-size:18px;
      text-transform:uppercase;
      color:var(--ui);
      background:rgba(255,255,255,.08);
      backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,.2);
      box-shadow:0 12px 30px -12px var(--shadow);
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
      text-align:center;
    }
    .btn:active{transform:translateY(1px)}

    /* Accent "Shoot Web" button — wider + same total height as stacked left/right */
    .btn.accent{
      width:160px;               /* keep wider */
      height:196px;              /* match two stacked buttons height + gap */
      font-size:22px;
      line-height:1.2;
      background:radial-gradient(circle at 30% 30%, rgba(255,45,85,.35), rgba(255,45,85,.15));
      border-color:rgba(255,45,85,.5);
      white-space:nowrap;
    }

    /* Backward (Left) button in blue glass */
    .btn.left-btn {
      background:radial-gradient(circle at 30% 30%, rgba(0,122,255,.35), rgba(0,122,255,.15));
      border-color:rgba(0,122,255,.5);
    }

    /* Forward (Right) button in green glass */
    .btn.right-btn {
      background:radial-gradient(circle at 30% 30%, rgba(52,199,89,.35), rgba(52,199,89,.15));
      border-color:rgba(52,199,89,.5);
    }

    /* Shoot Web stays red glass via .accent */
    /* Ensure icons inside colored glass buttons are white */
    .btn.left-btn,
    .btn.right-btn {
      color:#ffffff;   /* makes ◀︎ and ▶︎ white */
    }


    /* Simple cloud parallax visuals */
    .clouds{position:fixed;inset:0;overflow:hidden;pointer-events:none}
    .cloud{position:absolute;top:10%;width:220px;height:80px;border-radius:80px;background:rgba(255,255,255,.08);filter:blur(2px)}
    .cloud:before,.cloud:after{content:"";position:absolute;background:inherit;border-radius:inherit}
    .cloud:before{width:140px;height:60px;left:-40px;top:10px}
    .cloud:after{width:160px;height:70px;right:-40px;top:5px}

    /* Desktop-only help */
    @media (min-width: 900px){
      .hint{font-size:13px}
    }

    /* Square start menu layout */
    #startMenu .panel.start-square{
      width:min(92vw,300px);
      height:min(92vw,300px);
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:16px;
      padding:24px;
    }
    #startMenu .panel.start-square .title{margin:0;text-align:center;font-size:26px;font-weight:800}
    #startMenu .panel.start-square .score-cards{
      display:grid;grid-template-columns:1fr 1fr;align-items:center;justify-items:center;gap:10px
    }
    #startMenu .panel.start-square .score-card{display:flex;flex-direction:column;align-items:center;gap:8px}
    #startMenu .panel.start-square .label{font-size:14px;opacity:.9;margin:0}
    #startMenu .panel.start-square .score-big{font-size:44px;font-weight:900}
    #startMenu .panel.start-square .controls-square{display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
    #startMenu .panel.start-square .btn-ui{min-width:160px;height:44px;padding:0 16px;display:flex;align-items:center;justify-content:center}

    /* Square scorecard layout (single definition) */
    #scorecard .panel.score-square{
      width:min(92vw,400px);
      height:min(92vw,400px);
      display:grid;
      grid-template-rows:auto 1fr auto auto; /* title, main, input, buttons */
      gap:16px;
      padding:24px;
    }
    #scorecard .panel.score-square .title{margin:0;text-align:center;font-size:24px;font-weight:800}
    #scorecard .panel.score-square .score-main{
      display:grid;grid-template-columns:1fr 1fr;align-items:center;justify-items:center;gap:16px
    }
    #scorecard .panel.score-square .left{display:flex;flex-direction:column;align-items:center;gap:10px;width:100%}
    #scorecard .panel.score-square .badge-img{width:120px;height:120px;object-fit:contain;image-rendering:auto}
    #scorecard .panel.score-square .badge-msg{text-align:center;opacity:.95;min-height:28px}
    #scorecard .panel.score-square .right{display:flex;flex-direction:column;align-items:center;gap:8px}
    #scorecard .panel.score-square .score-big{font-size:48px;font-weight:900}
    #scorecard .panel.score-square .input-row{display:flex;justify-content:center}
    #scorecard .panel.score-square .input{width:min(100%,300px)}
    #scorecard .panel.score-square .input::placeholder{color:rgba(255,255,255,.6)}
    .visually-hidden{position:absolute !important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}
    #scorecard .panel.score-square .controls-square{display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
    #scorecard .panel.score-square .btn-ui{min-width:160px;height:44px;padding:0 16px;display:flex;align-items:center;justify-content:center}
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game" width="1280" height="720" aria-label="Spider Swinger Game Canvas"></canvas></div>
  <div class="hud">
    <div class="badge">
      <div class="score" id="score">Score: 0</div>
      <div class="hint">Desktop: W attach/release web • A/D move • S drop • R restart<br/>Mobile: use the buttons below<br/>Auto-respawn when you fall!</div>
    </div>
    <div class="badge" id="status">Swing: —</div>
  </div>

  <!-- Top-right Menu button -->
  <button id="openMenuBtn" class="btn btn-ui">Menu</button>

  <!-- Start Menu Overlay -->
  <div id="startMenu" class="overlay show" role="dialog" aria-modal="true">
    <div class="panel start-square">
      <h2 class="title">Octo Swinger</h2>
      <div class="score-cards">
        <div class="score-card">
          <div class="label">Best Score</div>
          <div id="bestScoreLabel" class="score-big">0</div>
        </div>
        <div class="score-card">
          <div class="label">Last Score</div>
          <div id="lastScoreLabel" class="score-big">0</div>
        </div>
      </div>
      <div class="controls-bar controls-square">
        <button id="startBtn" class="btn-ui">Start</button>
        <button id="openScorecardBtn" class="btn-ui">Download Score</button>
      </div>
    </div>
  </div>

  <!-- Scorecard Overlay -->
  <div id="scorecard" class="overlay" role="dialog" aria-modal="true">
    <div class="panel score-square">
      <h2 class="title">Score Card</h2>
      <div class="score-main">
        <div class="left">
          <img id="badgePreview" alt="badge" class="badge-img"/>
          <div id="badgeMessage" class="badge-msg"></div>
        </div>
        <div class="right">
          <div class="label">High Score</div>
          <div id="highScoreValue" class="score-big">0</div>
        </div>
      </div>
      <div class="input-row">
        <label class="visually-hidden" for="handleInput">Enter your X handle</label>
        <input id="handleInput" class="input" placeholder="Enter your X handle here!"/>
      </div>
      <div class="controls-bar controls-square">
        <button id="closeScorecardBtn" class="btn-ui">Close</button>
        <button id="downloadPngBtn" class="btn-ui">Download PNG</button>
      </div>
    </div>
  </div>

  <!-- Parallax clouds purely cosmetic -->
  <div class="clouds" aria-hidden="true">
    <div class="cloud" style="left:5%; top:12%; width:260px; opacity:.35"></div>
    <div class="cloud" style="left:35%; top:22%; width:220px; opacity:.28"></div>
    <div class="cloud" style="left:65%; top:16%; width:280px; opacity:.25"></div>
    <div class="cloud" style="left:80%; top:30%; width:200px; opacity:.2"></div>
  </div>

  <!-- Mobile controls -->
  <div class="controls" aria-label="Mobile Controls">
    <div class="pad left">
      <div class="btn left-btn" data-hold="left" aria-label="Move Left">◀︎</div>
      <div class="btn right-btn" data-hold="right" aria-label="Move Right">▶︎</div>
    </div>
    <div class="pad right">
      <div class="btn accent" data-hold="swing" aria-label="Shoot Web">Shoot Web</div>
    </div>
  </div>
  


  <script>
    // --- Utilities ---
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
    const lerp=(a,b,t)=>a+(b-a)*t;

    // --- Game setup ---
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    const statusEl=document.getElementById('status');
    const scoreEl=document.getElementById('score');
    const startMenu=document.getElementById('startMenu');
    const startBtn=document.getElementById('startBtn');
    const openMenuBtn=document.getElementById('openMenuBtn');
    const openScorecardBtn=document.getElementById('openScorecardBtn');
    const bestScoreLabel=document.getElementById('bestScoreLabel');
    const lastScoreLabel=document.getElementById('lastScoreLabel');
    const scorecard=document.getElementById('scorecard');
    const closeScorecardBtn=document.getElementById('closeScorecardBtn');
    const downloadPngBtn=document.getElementById('downloadPngBtn');
    const handleInput=document.getElementById('handleInput');
    const highScoreValue=document.getElementById('highScoreValue');
    const badgePreview=document.getElementById('badgePreview');
    const badgeMessage=document.getElementById('badgeMessage');

    let W=canvas.width, H=canvas.height;
    function resize(){
      const dpr=window.devicePixelRatio||1;
      canvas.width = Math.floor(window.innerWidth*dpr);
      canvas.height = Math.floor(window.innerHeight*dpr);
      W=canvas.width; H=canvas.height;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // --- World state ---
    const gravity=0.9;
    const moveAccel=0.6;
    const maxRunSpeed=8;

    const player={x:120,y:300,vx:0,vy:0,r:12,onGround:false,rope:null,ropeLen:0,dead:false};

    // Preload player sprite once (smoother)
    const spideyImg = new Image();
    spideyImg.src = 'player.png';
    let spideyReady=false;
    spideyImg.onload=()=>{ spideyReady=true; };

    const lavaHeight=120;
    const getLavaY = () => window.innerHeight - lavaHeight;

    let camX=0;

    const buildings=[]; // {x,w,h,top}
    const anchors=[];   // {x,y}

    function spawnInitialCity(){
      buildings.length=0; anchors.length=0;
      let x=0;
      for(let i=0;i<40;i++){
        const gap = (i===0)?0:Math.random()*90+60;
        x += gap + (i===0?0:buildings[i-1]?.w||0);
        const w=Math.random()*120+100;
        const h= lerp(window.innerHeight*0.25, window.innerHeight*0.6, Math.random());
        const top=getLavaY()-h;
        buildings.push({x,w,h,top});
        const aCount = Math.random()<0.5?1:2;
        for(let k=0;k<aCount;k++){
          const ax = x + lerp(10,w-10, k/(aCount-1||1));
          const ay = top - 60 - Math.random()*40;
          anchors.push({x:ax,y:ay});
        }
      }
    }

    function extendCityIfNeeded(){
      const last=buildings[buildings.length-1];
      if(!last || player.x + 3000 > last.x + last.w){
        let x = last ? last.x + last.w : 0;
        for(let i=0;i<20;i++){
          const gap = Math.random()*110+70;
          x += gap;
          const w=Math.random()*140+110;
          const h= lerp(window.innerHeight*0.25, window.innerHeight*0.65, Math.random());
          const top=getLavaY()-h;
          buildings.push({x,w,h,top});
          const aCount = Math.random()<0.45?1:2;
          for(let k=0;k<aCount;k++){
            const ax = x + lerp(14,w-14, k/(aCount-1||1));
            const ay = top - 70 - Math.random()*60;
            anchors.push({x:ax,y:ay});
          }
          x += w;
        }
      }
    }

    spawnInitialCity();

    // --- Input ---
    const keys={a:false,d:false,w:false,s:false};

    window.addEventListener('keydown',e=>{
      const k=e.key.toLowerCase();
      if(['w','a','s','d',' '].includes(k)) e.preventDefault();
      if(k==='a') keys.a=true;
      if(k==='d') keys.d=true;
      if(k==='w' || k===' ') keys.w=true;
      if(k==='s') keys.s=true;
      if(k==='r') restart();
    });
    window.addEventListener('keyup',e=>{
      const k=e.key.toLowerCase();
      if(k==='a') keys.a=false;
      if(k==='d') keys.d=false;
      if(k==='w' || k===' ') keys.w=false;
      if(k==='s') keys.s=false;
    });

    // Mobile buttons (hold behavior)
    const holds={left:false,right:false,swing:false,drop:false};
    for(const el of document.querySelectorAll('[data-hold]')){
      const name=el.getAttribute('data-hold');
      const set=(v)=>{holds[name]=v; if(name==='left') keys.a=v; if(name==='right') keys.d=v; if(name==='swing') keys.w=v; if(name==='drop') keys.s=v;};
      const start=(e)=>{e.preventDefault(); set(true)};
      const end=(e)=>{e.preventDefault(); set(false)};
      el.addEventListener('touchstart',start,{passive:false});
      el.addEventListener('touchend',end,{passive:false});
      el.addEventListener('touchcancel',end,{passive:false});
      el.addEventListener('mousedown',start);
      el.addEventListener('mouseup',end);
      el.addEventListener('mouseleave',end);
    }

    // --- Web attach/detach ---
    function tryAttachWeb(){
      const range=420;
      let best=null, bestD=1e9;
      const facing = keys.a? -1 : (keys.d? 1 : 1);
      const px=player.x, py=player.y;
      for(const a of anchors){
        const dx=a.x-px, dy=a.y-py;
        const dist=Math.hypot(dx,dy);
        if(dist<range && dist<bestD && Math.sign(dx)===Math.sign(facing)){
          best=a; bestD=dist;
        }
      }
      if(best){
        player.rope={x:best.x,y:best.y};
        player.ropeLen=bestD;
      }
    }
    function detachWeb(){ player.rope=null; }

    // --- Collision helpers ---
    function groundCollision(){
      player.onGround=false;
      for(const b of buildings){
        if(player.x> b.x && player.x < b.x+b.w){
          if(player.vy>=0 && player.y + player.r > b.top && player.y + player.r < b.top + 40){
            player.y=b.top - player.r; player.vy=0; player.onGround=true; return;
          }
        }
      }
    }

    // --- Scoring ---
    let score=0; let bestX=0; let passed=0;
    let highestScore= Number(localStorage.getItem('spider_high_score')||0);
    let lastScore=0;
    let gameActive=false;
    let inMenu=true;
    let respawnTimer=0;

    function updateScore(){
      if(!gameActive) return;
      bestX=Math.max(bestX, player.x);
      score = Math.floor(bestX*0.1 + passed*25);
      scoreEl.textContent = `Score: ${score}`;
    }

    function placePlayerOnFirstBuilding(){
      const first = buildings[0];
      if(first){
        player.x = first.x + Math.min(40, first.w*0.25);
        player.y = first.top - player.r;
        player.vx = 0;
        player.vy = 0;
        player.onGround = true;
        camX = 0;
      }
    }

    function restart(){
      player.vx=2; player.vy=0; player.rope=null; player.onGround=false; player.dead=false; 
      bestX=0; score=0; passed=0; camX=0; gameActive=true; respawnTimer=0;
      spawnInitialCity();
      placePlayerOnFirstBuilding();
      updateScoreDisplay();
    }

    function respawn(){
      player.vx=2; player.vy=0; player.rope=null; player.onGround=false; player.dead=false;
      bestX=0; score=0; passed=0; camX=0; gameActive=true; respawnTimer=0;
      placePlayerOnFirstBuilding();
      updateScoreDisplay();
    }

    // --- Menus & Scorecard ---
    function updateMenuLabels(){
      bestScoreLabel.textContent = highestScore;
      lastScoreLabel.textContent = lastScore;
    }

    function showMenu(){
      gameActive=false; inMenu=true; startMenu.classList.add('show');
      updateMenuLabels();
    }

    function hideMenu(){
      inMenu=false; startMenu.classList.remove('show');
    }

    function endRun(){
      lastScore = score;
      highestScore = Math.max(highestScore, lastScore);
      localStorage.setItem('spider_high_score', String(highestScore));
      updateScoreDisplay();
      updateMenuLabels();
    }

    function computeBadgeForScore(s){
      if(s<=500)   return {name:'toddler', path:'action-icons/toddler.png', msg:'You are a Toddler'};
      if(s<=2000)  return {name:'ninja',   path:'action-icons/ninja.png',   msg:'You have good ninja stealth.'};
      if(s<=4000)  return {name:'samurai', path:'action-icons/samurai.png', msg:'You are a Samurai.'};
      if(s<=6000)  return {name:'spartan', path:'action-icons/spartan.png', msg:'You are a Spartan.'};
      if(s<=8000)  return {name:'messiah', path:'action-icons/messiah.png', msg:'You are Messiah'};
      return {name:'god', path:'action-icons/god.png', msg:'Congratulations, you are a God.'};
    }

    function openScorecard(){
      const badge=computeBadgeForScore(highestScore);
      badgePreview.src = badge.path;
      badgePreview.alt = badge.name;
      highScoreValue.textContent = highestScore;
      badgeMessage.textContent = badge.msg;
      scorecard.classList.add('show');
    }

    function closeScorecard(){ scorecard.classList.remove('show'); }

    // --- Download card PNG with exact boxes ---
    function downloadScorecardPng(){
      const s = highestScore;

      // Choose card image by score range
      const cardSrc =
        (s <= 500)  ? 'toddler-card.png' :
        (s <= 2000) ? 'ninja-card.png'   :
        (s <= 4000) ? 'samurai-card.png' :
        (s <= 6000) ? 'spartan-card.png' :
        (s <= 8000) ? 'messiah-card.png' :
                      'god-card.png';

      const handleRaw = (handleInput.value || '').trim();
      const handle = handleRaw ? (handleRaw.startsWith('@') ? handleRaw : '@' + handleRaw) : '@anonymous';

      // Helper: fit text into rect
      function drawFittedText(g, text, rect, opts = {}){
        const {
          weight='900', preferredSize=64, minSize=18,
          family='Inter, Arial, sans-serif',
          align='center', vAlign='middle',
          padding=12, baseline='alphabetic', lineHeight=1.0
        } = opts;
        let fontSize = preferredSize;
        g.textAlign = align;
        g.textBaseline = baseline;
        g.fillStyle = '#222222';
        const maxWidth = rect.w - padding*2;
        const maxHeight = rect.h - padding*2;
        while (fontSize >= minSize){
          g.font = `${weight} ${fontSize}px ${family}`;
          const width = g.measureText(text).width;
          const height = fontSize * lineHeight;
          if (width <= maxWidth && height <= maxHeight) break;
          fontSize -= 1;
        }
        let x;
        if (align==='left') x = rect.x + padding;
        else if (align==='center') x = rect.x + rect.w/2;
        else x = rect.x + rect.w - padding;
        let y;
        if (vAlign==='top'){ g.textBaseline='top'; y = rect.y + padding; }
        else if (vAlign==='middle'){ g.textBaseline='middle'; y = rect.y + rect.h/2; }
        else { g.textBaseline='bottom'; y = rect.y + rect.h - padding; }
        g.fillText(text, x, y);
      }

      const base = new Image();
      base.onload = () => {
        const w = base.naturalWidth, h = base.naturalHeight;
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        const g = c.getContext('2d');

        g.drawImage(base, 0, 0, w, h);

        // Exact areas
        const HS_BOX     = { x:1176, y:70,  w:378,  h:212 };
        const HANDLE_BOX = { x: 644, y:461, w:1000, h:121 };

        // Label
        drawFittedText(g, 'High Score', HS_BOX, {
          weight:'700', preferredSize:40, minSize:20, align:'center', vAlign:'top', padding:22
        });
        // Number
        const SCORE_SUB = { x:HS_BOX.x, y:HS_BOX.y+78, w:HS_BOX.w, h:HS_BOX.h-78 };
        drawFittedText(g, String(highestScore), SCORE_SUB, {
          weight:'900', preferredSize:112, minSize:28, align:'center', vAlign:'middle', padding:20
        });
        // Handle (left aligned)
        drawFittedText(g, handle, HANDLE_BOX, {
          weight:'700', preferredSize:54, minSize:22, align:'left', vAlign:'middle', padding:28
        });

        const a=document.createElement('a');
        a.download='scorecard.png';
        a.href=c.toDataURL('image/png');
        a.click();
      };
      base.src = cardSrc;
    }

    // Buttons
    startBtn.addEventListener('click',()=>{ hideMenu(); restart(); gameActive=true; });
    openMenuBtn.addEventListener('click',()=>{ showMenu(); });
    openScorecardBtn.addEventListener('click',()=>{ openScorecard(); });
    closeScorecardBtn.addEventListener('click',()=>{ closeScorecard(); });
    downloadPngBtn.addEventListener('click',()=>{ downloadScorecardPng(); });

    // --- Score Display ---
    function updateScoreDisplay(){
      if(gameActive){
        scoreEl.textContent = `Score: ${score}`;
      } else {
        scoreEl.textContent = `Latest: ${lastScore} | Best: ${highestScore}`;
      }
    }

    // --- Main loop ---
    let lastTs=0;
    function step(ts){
      const dt = Math.min(33, ts-lastTs || 16);
      lastTs=ts;

      if(inMenu){
        render();
        requestAnimationFrame(step);
        return;
      }

      extendCityIfNeeded();

      // Movement
      if(player.onGround){
        if(keys.a) player.vx = clamp(player.vx - moveAccel, -maxRunSpeed, maxRunSpeed);
        if(keys.d) player.vx = clamp(player.vx + moveAccel, -maxRunSpeed, maxRunSpeed);
        if(!keys.a && !keys.d) player.vx *= 0.86;
      }

      // Attach/Detach
      if(keys.w && !player.rope) tryAttachWeb();
      if(!keys.w && player.rope) detachWeb();
      if(keys.s) detachWeb();

      // Physics
      player.vy += gravity;
      player.x += player.vx; 
      player.y += player.vy;

      // Rope constraint
      if(player.rope){
        const rx = player.rope.x - player.x;
        const ry = player.rope.y - player.y;
        const dist = Math.hypot(rx,ry) || 1;
        if(dist>player.ropeLen){
          const nx = rx/dist, ny = ry/dist;
          const px = player.rope.x - nx*player.ropeLen;
          const py = player.rope.y - ny*player.ropeLen;
          const dx = px - player.x, dy = py - player.y;
          player.x = px; player.y = py;
          const vDot = player.vx*nx + player.vy*ny;
          player.vx -= vDot*nx;
          player.vy -= vDot*ny;
          const tangentX = -ny, tangentY = nx;
          if(keys.d) { player.vx += tangentX*0.25; player.vy += tangentY*0.25; }
          if(keys.a) { player.vx -= tangentX*0.25; player.vy -= tangentY*0.25; }
        }
      }

      // Collisions with rooftops
      groundCollision();

      // Lava hazard
      const lavaY = getLavaY();
      if(player.y + player.r >= lavaY){
        if(gameActive){
          player.dead=true; gameActive=false;
          highestScore = Math.max(highestScore, score);
          updateScoreDisplay();
          respawnTimer = 120;
          endRun();
        }
      }

      // Fallback fail below screen
      if(player.y - player.r > H + 300){ 
        if(gameActive) {
          player.dead=true; gameActive=false;
          highestScore = Math.max(highestScore, score);
          updateScoreDisplay();
          respawnTimer = 120;
          endRun();
        }
      }
      
      // Respawn timer
      if(respawnTimer > 0) {
        respawnTimer--;
        if(respawnTimer === 0) respawn();
      }
      
      statusEl.textContent = player.dead ? 'Game Over — respawning in 2s...' : (player.rope ? 'Swing: attached' : 'Swing: free');

      // Camera follow
      camX = lerp(camX, player.x - window.innerWidth*0.35, 0.08);

      // Count passed buildings
      for(let i=passed;i<buildings.length;i++){
        if(buildings[i].x + buildings[i].w < player.x){ passed=i; }
        else break;
      }

      if(gameActive){ updateScore(); }
      render();
      requestAnimationFrame(step);
    }

    // --- Render ---
    function render(){
      const vw = window.innerWidth; const vh = window.innerHeight;
      ctx.clearRect(0,0,vw,vh);

      // Parallax distant skyline
      const layers=[
        {offset:0.2,color:'rgba(10,16,28,0.6)'},
        {offset:0.35,color:'rgba(10,20,34,0.75)'}
      ];
      layers.forEach((layer,idx)=>{
        ctx.fillStyle=layer.color;
        for(let i=0;i<buildings.length;i+=2){
          const b=buildings[i];
          const x = Math.floor(b.x*layer.offset - camX*layer.offset);
          const w=b.w*0.9;
          const h=b.h*0.9 + (idx*20);
          ctx.fillRect(x, vh - h*0.75, w, h*0.75);
        }
      });

      // Foreground buildings
      for(const b of buildings){
        const x = Math.floor(b.x - camX);
        const y = b.top;
        if(x+b.w < -200 || x > window.innerWidth+200) continue;
        const g=ctx.createLinearGradient(0,y,0,vh);
        g.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--building'));
        g.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--building2'));
        ctx.fillStyle=g;
        ctx.fillRect(x, y, b.w, b.h);
        ctx.fillStyle='rgba(255,255,255,0.06)';
        const cw=12,ch=18, gap=10;
        for(let cx=x+14; cx<x+b.w-10; cx+=cw+gap){
          for(let cy=y+14; cy<y+b.h-20; cy+=ch+gap){
            if(Math.random()>0.9) continue;
            ctx.fillRect(cx, cy, cw, ch);
          }
        }
      }

      // Anchors
      ctx.fillStyle='rgba(255,255,255,0.6)';
      for(const a of anchors){
        const x = Math.floor(a.x - camX), y=a.y;
        if(x<-20||x>window.innerWidth+20) continue;
        ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fill();
      }

      // Rope
      if(player.rope){
        ctx.strokeStyle='rgba(255,255,255,0.8)';
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(player.rope.x - camX, player.rope.y);
        ctx.lineTo(player.x - camX, player.y);
        ctx.stroke();
      }

      // Lava
      const lavaTop = getLavaY();
      const lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, vh);
      lavaGrad.addColorStop(0,'rgba(255,120,40,0.9)');
      lavaGrad.addColorStop(0.35,'rgba(255,80,20,0.9)');
      lavaGrad.addColorStop(1,'rgba(160,20,20,1)');
      ctx.fillStyle = lavaGrad;
      ctx.fillRect(0, lavaTop, vw, vh - lavaTop);

      const glow = ctx.createLinearGradient(0, lavaTop-40, 0, lavaTop+10);
      glow.addColorStop(0,'rgba(255,120,40,0)');
      glow.addColorStop(1,'rgba(255,120,40,0.25)');
      ctx.fillStyle=glow; ctx.fillRect(0, lavaTop-40, vw, 50);

      // Player sprite (preloaded)
      if (spideyReady){
        const px = player.x - camX, py = player.y;
        const size = player.r * 3 + 4;
        ctx.drawImage(spideyImg, px - size/2, py - size/2, size, size);
      }

      // Ground fade
      const grd=ctx.createLinearGradient(0, vh-120, 0, vh);
      grd.addColorStop(0,'rgba(0,0,0,0)'); grd.addColorStop(1,'rgba(0,0,0,.3)');
      ctx.fillStyle=grd; ctx.fillRect(0, vh-120, vw, 120);
    }

    // Boot
    spawnInitialCity();
    placePlayerOnFirstBuilding();
    showMenu();
    requestAnimationFrame(step);
  </script>
</body>
</html>
